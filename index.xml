<?xml version="1.0" encoding="utf-8" standalone="no"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <updated>2017-01-04T09:44:41.428Z</updated>
  <entry>
    <title>Published Articles</title>
    <content/>
  </entry>
  <entry>
    <title>10 Simple Quick Keys in BASH to Make Your Life Easier</title>
    <author/>
    <content>Knowing how to quickly manipulate the command line in the BASH shell will save you a lot of time and frustration.  Here are 10 Simple key combinations that will make your life easier and speed up your line editing skills.

CTRL + a - Places your cursor at the beginning of the line you are on

CTRL + e - Places your cursor at the end of the current line you are on

CTRL + u - Clears the line of everything &lt;b&gt;BEFORE&lt;/b&gt; the cursor

CTRL + k - Clears the line of everything &lt;b&gt;AFTER&lt;/b&gt; the cursor

CTRL + d - Deletes the character under the curser

CTRL + p - Goes back a previous command in history.  This is the same as using the up arrow.

CTRL + n - Goes forward a command in history.  This is the same as using the down arrow.

ALT + f - Move forward one word

ALT + b - Move backward one word

ALT + . - Inserts the last word from the previous history entry
</content>
  </entry>
  <entry>
    <title>How to add a new Linux user account</title>
    <author/>
    <content>Adding a new user to a Linux machine is one of the simplest things to do. The useradd command works under any linux distro. You will however need to be root to add the new user via the useradd command, the syntax is as follows:&#xD;
&#xD;
**useradd [options] (username)**&#xD;
&#xD;
By using the above command, it will do everything for you including creating the user's home directory, adding them to /etc/passwd and /etc/shadow. So let's say you wanted to add a new user named digest, you would simply do the following:&#xD;
&#xD;
```bash&#xD;
$ useradd digest&#xD;
```&#xD;
&#xD;
One example that you can use for the options as well is to add a user to a particular group when you add them.. For example, let's say we wanted the digest user to be in the wheel group so they can sudo to root. We would simply issue the following command:&#xD;
&#xD;
```bash&#xD;
$ useradd -G wheel digest&#xD;
```&#xD;
&#xD;
Or if you wanted to create a group with the same username you can use the -U flag like so:&#xD;
&#xD;
```bash&#xD;
$ useradd -U digest&#xD;
```&#xD;
&#xD;
If you added the user, you then need to set a user's password. If you do not set a user's password the account will be in a locked status. To unlock it, simply issue the following command to set a password:&#xD;
&#xD;
```bash&#xD;
$ passwd digest&#xD;
```&#xD;
&#xD;
It then will prompt you to input the new password, and to confirm the new password.&#xD;
&#xD;
There are many additional features and things you can do with the useradd command, simply run man useradd on a linux server to see all the different flags.&#xD;
</content>
  </entry>
  <entry>
    <title>Adding JS &amp; CSS Files To CKEditor Content</title>
    <author/>
    <content>Recently, I've been working on a web-development project (Which I'm omitting from this post), which uses the popular WYSIWYG editor, [CKEditor](http://ckeditor.com/).&#xD;
&#xD;
A popular issue with WYSIWYG editors, is even though they have display a very accurate depiction of what the content will look like as pure HTML, the content still looks different from what it will be when it's actually injected into your page, this is typically because your page has CSS and JS to aid in styling, where as the WYSIWYG editor does not.&#xD;
&#xD;
Like CKEditor, most of the common RTE's use an iFrame for the content, which is why the CSS/JS is not reflected in the content. I think this actually is done intentionally, to show what it will look like as html exactly, and only html, without any outside interference.&#xD;
&#xD;
However, I wanted the CSS/JS inside the content. After looking a little bit, I did find a plugin on the CKEditor website, called [CKEditor Include CSS &amp; JS](http://ckeditor.com/addon/doksoftinclude), which seemed to accomplish exactly what I wanted.&#xD;
&#xD;
Two problems with this plugin...&#xD;
&#xD;
1. I don't like to pay for such little software packages. I don't at all mind paying for things like Jira for example, but this just seemed to minor&#xD;
2. We aren't absolutely sure if the project I'm working on will be Open Source or not, or a mixture. If it's not, then this would need to be a factor in any 3rd party software, and if I move forward as if its going to be Open Source, and its not, then that means I would have to go back and re-factor a lot of code.&#xD;
&#xD;
So, I decided to just do it myself, which was actually just as easy as it sounds. I can't believe people pay for software like this, lol.&#xD;
&#xD;
Before I show the code below and explain it, let me stress that I am NOT a professional web developer, I'm a Linux Engineer, I just so happen to  know a good amount of web development skills...&#xD;
### How to use...&#xD;
&#xD;
	1. Set the ckeditor_id value to the ID of the textarea using CKEditor&#xD;
	2. Set the value of container_classes to whatever classes the final HTML will be displayed in when displayed on the web-page. Since the ALL CSS/JS of the page will be reflected in the content of the textarea, it's important to set this value correctly, or it may look completely different.&#xD;
	3. Copy/Paste the code to wherever you want it to execute.&#xD;
&#xD;
### Whats it do...&#xD;
1. Look through the current page for any CSS files, specifically looking for any **_&amp;lt;link&amp;gt;_** tags that have the attribute/value of **_type="text/css"_**, which if done properly, all of the link tags should have (if loading CSS), load the value of _ **href** _ into an array.&#xD;
2. Do the same thing with Javascript files, looking for any **_&amp;lt;script&amp;gt;_** tags with the attribute/value of _ **type="text/javascript"** _, load the value of _ **src** _ into an array.&#xD;
3. Find the CKEditor instance by looking for an instance named by the value of the variable **_ckeditor_id_**&#xD;
4. If you have any extra CKEditor settings, apply them here....&#xD;
5. Waits for the CKEditor instance to be fully initialized, this takes longer than window.load or document.ready, so wait for CKEditors **_instanceReady_** event handler.&#xD;
6. Once initialized, look for the correct frame associated to the CKEditor you specified in the _ **ckeditor_id** _ variable. This will look for the correct iframe, not just any iframe. Then create a handler referencing the **_&amp;lt;head&amp;gt;_** of that iframe&#xD;
7. Loop through the array created earlier with the CSS files and create a new **_&amp;lt;link&amp;gt;_** tag with the stylesheet source as the source collected earlier&#xD;
8. Do the same thing with the array created earlier with the JS files, creating a _ **&amp;lt;script&amp;gt;** _ tag with the javascript href as the href collected earlier&#xD;
&#xD;
And finally, you can view the code here:&#xD;
&#xD;
```javascript&#xD;
// I find its best to do this in window.load as opposed to document.ready, since all the&#xD;
// DOM elements are then loaded&#xD;
$( window ).load(function(){&#xD;
    // ID of the cKeditor instance&#xD;
    var ckeditor_id = 'your_ckeditor_id';&#xD;
    var container_classes = 'panel-body panel';&#xD;
&#xD;
    var $head = $('head');&#xD;
    var css_files = [];&#xD;
    var js_files = [];&#xD;
&#xD;
    // Get all CSS files of the current page&#xD;
    $head.find('link[type=&amp;quot;text/css&amp;quot;]' ).each(function(i,css){&#xD;
        css_files.push($(css).attr('href'));&#xD;
    });&#xD;
&#xD;
    // Then get all the JS files&#xD;
    $head.find('script[type=&amp;quot;text/javascript&amp;quot;]' ).each(function(i,js){&#xD;
        js_files.push($(js).attr('src'));&#xD;
    });&#xD;
&#xD;
    // CKeditor handler&#xD;
    var $ckeditor = CKEDITOR.instances[ckeditor_id];&#xD;
&#xD;
    // Add whatever class(es) are of the DIV/SPAN that you will be displaying the content in&#xD;
    $ckeditor.config.bodyClass = container_classes;&#xD;
&#xD;
    // Wait for the CKeditor instance to be initiated, it takes a bit longer&#xD;
    // than just window.load, but it has an event handler&#xD;
    CKEDITOR.on('instanceReady', function(){&#xD;
        // Find the exact iframe thats used by this ckeditor_id textarea&#xD;
        var $ckeditor_frame = $('#cke_' + ckeditor_id).find('.cke_wysiwyg_frame');&#xD;
&#xD;
        // Head element of CKEditors iFrame&#xD;
        var $ckeditor_head  = $ckeditor_frame.contents().find(&amp;quot;head&amp;quot;);&#xD;
&#xD;
        // Add all the CSS files..&#xD;
        $.each(css_files, function(i,css_file){&#xD;
            $ckeditor_head.append($(&amp;quot;&amp;lt;link/&amp;gt;&amp;quot;, {&#xD;
                rel: &amp;quot;stylesheet&amp;quot;,&#xD;
                href: css_file,&#xD;
                type: &amp;quot;text/css&amp;quot;&#xD;
            }));&#xD;
        });&#xD;
&#xD;
        // Then add all the JS files..&#xD;
        $.each(js_files, function(i,js_file){&#xD;
            $ckeditor_head.append($(&amp;quot;&amp;lt;script/&amp;gt;&amp;quot;, {&#xD;
                src: js_file,&#xD;
                type: &amp;quot;text/javascript&amp;quot;&#xD;
            }));&#xD;
        });&#xD;
&#xD;
        // DONE!&#xD;
    });&#xD;
});&#xD;
```&#xD;
</content>
  </entry>
  <entry>
    <title>Alternatives To Commonly Used Linux Commands</title>
    <author/>
    <content>In my opinion, one of the best things about Unix/Linux, is there's typically always more than one correct way to do something. Sometimes, some ways are better than others, or quicker or more efficient or reliable, but it's common to get locked into doing something one specific way just because you've done it repeatedly. There's always alternative methods of accomplishing a task, like if you wanted to find out what ports are open on a server, depending on if you are on the server itself or not, you have lsof, nmap, netstat&#xD;
&#xD;
I like to research alternative methods of accomplishing common tasks, just to see if there's a better way of doing.... whatever it is I'm doing.&#xD;
&#xD;
## Traceroute vs. MTR&#xD;
The _[traceroute](http://linux.die.net/man/8/traceroute "Traceroute Man Page")_ command is probably one of the most commonly used commands for diagnosing network related issues. It's a fairly simple command, you just run something like 'traceroute google.com' and it&#xD;
&#xD;
Screenshot of the difference between the output of traceroute and the output of mtr&#xD;
![Screenshot of the difference between the output of traceroute and the output of mtr](/assets/articles/traceroute_vs_mtr.png)&#xD;
&#xD;
will print the route packets trace to whatever host you specified (google.com, in my example).&#xD;
&#xD;
What if you are waiting for something to change though? Most administrators would combined _traceroute_ with the _[watch](http://linux.die.net/man/1/watch "Linux Watch Man Page")_ command, or even worse, hit the up arrow and hit enter about a thousand times.&#xD;
&#xD;
There's a great alternative to this, it's a command called [mtr](http://linux.die.net/man/8/mtr "Linux Man Page MTR"). _mtr_ isn't always installed by default, so you may need to use your package installer to install it.&#xD;
&#xD;
_mtr_ is essentially a live feed of the _traceroute_ output (Screenshot above). It also will show you packet loss on each hop in a live feed, which is what you would alternatively be using _ping_ to do, so you could say this accomplishes both _traceroute_ and _ping_. This is very useful when you're waiting for something to change, or if you need to actively monitor the path to a server, etc.&#xD;
&#xD;
___&#xD;
## Top vs. Htop&#xD;
&#xD;
Even more popular than the _traceroute_ command would be top. I think top is probably the first command you learn as a sys admin, as far as diagnostics goes. Top will show you the load averages, the top&#xD;
&#xD;
Difference in the output of the commands top and htop&#xD;
![Command outputs of TOP and HTOP](/assets/articles/top_vs_htop.png)&#xD;
&#xD;
Resource intensive processes, the users, pids, memory utilization, CPU utilization, pretty much everything you need to know. If you want to manipulate the output (Such as sort by CPU or Memory, only show specific user processes, or show a tree view for example), that can only be accomplished using the arguments associated with top when you run the command itself.&#xD;
&#xD;
An awesome alternative to _top_, is [htop](http://linux.die.net/man/1/htop "Linux Command Htop Man Page"). Htop will provide you with essentially the same functionally as top, except the interface of htop is fully interactive! You have the ability to actively manipulate the output or interact with the processes in the output, using the F-keys:&#xD;
&#xD;
**F4** lets you filter the output so you can look for specific commands; **F5** will display the processes in a tree view, showing each parent and child process; **F6** lets you pick a column to sort by, and how to sort it; **F7** and **F8** let you manipulate the nice level of the process; **F9** lets you pick a process to terminate, as well as which kill signal to send, and you can escape htop with **F10**&#xD;
&#xD;
Just like mtr (and most of the commands listed here), you will need to install this using your package manager.&#xD;
&#xD;
**Note**: _htop_ will only display processes that it has permissions to, so if you want to see all of the processes on the system, be sure to use sudo. I would just recommending adding an alias to your ~/.bash_profile to alias htop="sudo htop"&#xD;
&#xD;
Also...  Another alternative to _top_, for monitoring system utilization and resources, would be _[atop](http://linux.die.net/man/1/atop "Linux Man Page Command atop")_. The output of _atop_ is much more informational than the standard _top_ command, but its not at all interactive.&#xD;
&#xD;
___&#xD;
## Less vs More&#xD;
This ones pretty simple actually. Both less and _more_ are just simply pagers. The key difference between Less and More is, More permits you to view the contents of the file, while scrolling down only, you can not scroll up in More. However, with Less, you can scroll up AND down.&#xD;
&#xD;
I think the irony in the names is just a simple pun, _less_ is _more_, and _more_ is _less_!..&#xD;
&#xD;
___&#xD;
## Nslookup vs Dig &amp; Host&#xD;
![Nslookup_VS_Dig_VS_Host](/assets/articles/Nslookup_VS_Dig_VS_Host.png)&#xD;
&#xD;
[Nslookup](http://linux.die.net/man/1/nslookup "Nslookup man page") is probably one of the most popular commands for any sysadmin. It's a fairly simple command, all it does is return the DNS record of whatever is provided to it as an argument.&#xD;
&#xD;
[Dig](http://linux.die.net/man/1/dig "Dig man page") is pretty simple to use, and a lot more informational than _nslookup_. It gives you a more in-depth response about the answer provided; Regurgitates the query you requested back to you; Gives you the answers under the answer section; As well as which server was used to query, and the time the query was performed. Yes, some of this is provided by _nslookup_, but not all of it.&#xD;
&#xD;
The [host](http://linux.die.net/man/1/host "Host command man page") command basically simplifies both nslookup and dig about as much as it can, which is great for scripting or whenever you need to get right down to the point.&#xD;
&#xD;
If this isn't enough as it is... _nslookup_ is deprecated. The organization that maintains the code for _nslookup_, Internet Systems Consortium, has very clearly stated so. So I would think that says enough as it is.&#xD;
&#xD;
**Source:** [blog.smalleycreative.com](http://blog.smalleycreative.com/linux/nslookup-is-dead-long-live-dig-and-host/)&#xD;
&#xD;
___&#xD;
## Di vs Df (and Du)&#xD;
![Output comparison between DU, DF and DI](/assets/articles/df_vs_du_vs_di.png "DU, DF and DI")&#xD;
&#xD;
Pretty much everyone knows about [df](http://linux.die.net/man/1/df) but theirs one I just learned about. it's called [di](http://linux.die.net/man/1/di), which means Disk Information, (I bet you could have guessed that :-P)&#xD;
&#xD;
df is a very popular command, used by administrators and scripts very frequently, but still it doesn't provide some excellent and useful features like actual disk space that is available to each user, various useful display formats etc.&#xD;
&#xD;
You can see in the screenshot on the right, the information provided by the commands _df_, _du_ and _di_. _Di_ provides more information, and is just as quick as _df_, and accurate as _du_, (I'm not quite sure how that's possible... yet, if you know, please comment on this post).&#xD;
&#xD;
___&#xD;
## Vi vs VIM&#xD;
![VIM Plugin YouCompleteMe](/assets/articles/youcompleteme.gif "VIM Plugin YouCompleteMe")&#xD;
&#xD;
At first glance to me, VIM was nothing more than VI with syntax highlighting. But after further research, I found some differences than count for more than just syntax highlighting.&#xD;
&#xD;
VI comes installed on most OS's by default, but its not nearly as powerful as VIM.&#xD;
&#xD;
VIM allows plugins, plugins that won't work with just the simple VI binary by itself. Getting the list of plugins is a while other post, but ill tell you right now that one worth checking into is called [You Complete Me](https://github.com/Valloric/YouCompleteMe). Heres a quick snippet of what YCM is...&#xD;
&#xD;
&#xD;
&gt; YouCompleteMe is a fast, as-you-type, fuzzy-search code completion engine for [Vim](http://www.vim.org/). It has several completion engines: an identifier-based engine that works with every programming language, a semantic, [Clang](http://clang.llvm.org/)-based engine that provides native semantic code completion for C/C++/Objective-C/Objective-C++ (from now on referred to as "the C-family languages"), a [Jedi](https://github.com/davidhalter/jedi)-based completion engine for Python, an [OmniSharp](https://github.com/nosami/OmniSharpServer)-based completion engine for C# and an omnifunc-based completer that uses data from Vim's omnicomplete system to provide semantic completions for many other languages (Ruby, PHP etc.).&#xD;
&#xD;
&#xD;
Just a couple more cool things that VIM can accomplish that you can't do directly with VI.. You may have to have all of the VIM packages vim-full. I would just use yum or apt-get to install vim-\*, I think  thats around 25 packages, depending on your distro.&#xD;
&#xD;
* Editing files on other locations using network protocols such as SSH, SCP or even HTTP&#xD;
* You can modify files inside compressed archives. as-is&#xD;
* VIM is becoming more and more common, and being ported to much more distros of OS than VI is&#xD;
* VIM comes with something called 'vimdiff'. which allows you to compare two files&#xD;
* With VIM, you can split the screen for editing multiple files, which is actually very handy when having to do things at the console, and you cant use terminator. Just have to learn the controls, somewhat like [screen](http://linux.die.net/man/1/screen).&#xD;
&#xD;
Thats all I have for now. I definitely prefer VIM to VI, but as long as you don't use NANO... you're OK in my book ;-)&#xD;
</content>
  </entry>
  <entry>
    <title>How to check if ETags are being served</title>
    <author/>
    <content>We all know of the Apache ETag vulnerability, and if you don't know how to fix it, it's pretty quite simple -- all you need to do is add: ETag None to your apache vhost configuration and restart apache. But one of the questions came across of, how do we validate that this fix actually happened or not? It's actually quite simple, all you need to do is curl and look at the headers that are returned from the server to see if it's there or not..&#xD;
&#xD;
Example of before the fix:&#xD;
&#xD;
```bash&#xD;
$ curl -I https://hostname.com/ -k&#xD;
HTTP/1.1 200 OK&#xD;
Date: Thu, 20 Feb 2014 17:45:10 GMT&#xD;
Server: Apache&#xD;
Last-Modified: Tue, 12 Aug 2008 22:07:29 GMT&#xD;
ETag: &amp;quot;802a3-83b-99a202a5&amp;quot;&#xD;
Accept-Ranges: bytes&#xD;
Content-Length: 875&#xD;
Content-Type: text/html; charset=UTF-8&#xD;
```&#xD;
&#xD;
Example of after the fix:&#xD;
&#xD;
```bash&#xD;
$ curl -I https://hostname.com/ -k&#xD;
HTTP/1.1 200 OK&#xD;
Date: Thu, 20 Feb 2014 17:45:22 GMT&#xD;
Server: Apache&#xD;
Last-Modified: Tue, 12 Aug 2008 18:17:46 GMT&#xD;
Accept-Ranges: bytes&#xD;
Content-Length: 875&#xD;
Content-Type: text/html; charset=UTF-8&#xD;
```&#xD;
&#xD;
As you can see above, the first curl command returns the ETag information, and the second one does not and this will allow you to close out that vulnerability! :)&#xD;
</content>
  </entry>
  <entry>
    <title>Automate server backups to Amazon S3</title>
    <author/>
    <content>I've always tried to figure out what the best way would be to backup a server, without me having to do anything at all. I looked online and found a lot of great websites, software that does it but everything is extremely expensive especially for storing your backups. If there is a free method out there, I am one to try and go that route and give it a try to get everything set up properly before I start investing my money into paid products and what is really funny about that is sometimes the free products work WAY better than the paid products.&#xD;
&#xD;
Anyway, here is how I automated my server backups to Amazon S3 using their free usage tier which provides 5 GB of Amazon S3 storage, 20,000 Get Requests, 2,000 Put Requests, and 15GB of data transfer out each month for one year. Yes, after the year is up you have to pay but even then if you look at the storage pricing it is [extremely cheap](https://aws.amazon.com/s3/pricing/)&#xD;
&#xD;
First off you need to install a tool called s3cmd on your server. You can find the s3cmd page by navigating [here](http://s3tools.org/s3cmd)&#xD;
&#xD;
Once you get s3cmd installed then you need to configure it using the --configure flag&#xD;
&#xD;
```bash&#xD;
# s3cmd --configure&#xD;
```&#xD;
&#xD;
Then input all of the information that it reqeusts such as access key and secret key (click [HERE](https://www.amazon.com/gp/redirect.html?ie=UTF8&amp;amp;location=https%3A%2F%2Faws-portal.amazon.com%2Fgp%2Faws%2Fdeveloper%2Faccount%2Findex.html%2F?action=access-key&amp;amp;tag=bucket-20) to be taken directly to your access keys), your encryption password which is used to password protect your files, https yes/no, http proxy settings, etc. Here is an example output:&#xD;
&#xD;
```bash&#xD;
# s3cmd --configure&#xD;
&#xD;
Enter new values or accept defaults in brackets with Enter.&#xD;
Refer to user manual for detailed description of all options.&#xD;
&#xD;
Access key and Secret key are your identifiers for Amazon S3&#xD;
Access Key []:&#xD;
Secret Key []:&#xD;
&#xD;
Encryption password is used to protect your files from reading&#xD;
by unauthorized persons while in transfer to S3&#xD;
Encryption password []:&#xD;
Path to GPG program [/usr/bin/gpg]:&#xD;
&#xD;
When using secure HTTPS protocol all communication with Amazon S3&#xD;
servers is protected from 3rd party eavesdropping. This method is&#xD;
slower than plain HTTP and can\'t be used if you\'re behind a proxy&#xD;
Use HTTPS protocol [No]:&#xD;
&#xD;
On some networks all internet access must go through a HTTP proxy.&#xD;
Try setting it here if you can\'t conect to S3 directly&#xD;
HTTP Proxy server name:&#xD;
&#xD;
New settings:&#xD;
 Access Key: &lt;YOUR ACCESS KEY&gt;;&#xD;
 Secret Key: &lt;YOUR SECRET KEY&gt;;&#xD;
 Encryption password: &lt;YOUR PASSWORD&gt;;&#xD;
 Path to GPG program: /usr/bin/gpg&#xD;
 Use HTTPS protocol: False&#xD;
 HTTP Proxy server name:&#xD;
 HTTP Proxy server port: 0&#xD;
&#xD;
Test access with supplied credentials? [Y/n] y&#xD;
Please wait...&#xD;
Success. Your access key and secret key worked fine&#xD;
&#xD;
Now verifying that encryption works...&#xD;
Success. Encryption and decryption worked fine&#xD;
&#xD;
Save settings? [y/N] y&#xD;
Configuration saved to '/root/.s3cfg'&#xD;
```&#xD;
&#xD;
Once you have all of that setup and configured, then you need to create a backup directory, this is the directory that your backups will be placed in. I personally made it /backup and inside that directory create a Archive, Data, and MySQL directories. At the end of it your directory should look like this:&#xD;
&#xD;
```bash&#xD;
/backups&#xD;
/backups/Archive&#xD;
/backups/Data&#xD;
/backups/MySQL&#xD;
```&#xD;
&#xD;
Now make sure you have File::NFSLock and Date::Format perl modules installed on your system if you don't install them via cpan (cpan -i File::NFSLock/Date::Format) and put the following script on your server:&#xD;
&#xD;
```perl&#xD;
#!/usr/bin/perl&#xD;
&#xD;
use Fcntl qw(LOCK_EX LOCK_NB);&#xD;
use File::NFSLock;&#xD;
use Date::Format;&#xD;
&#xD;
# Include the directories you wish to backup separated by space, like so:&#xD;
# my $datadirs = "/home /root /var/tools /www";&#xD;
my $datadirs = "### INPUT YOUR DIRECTORIES ###";&#xD;
&#xD;
# Try to get an exclusive lock on myself.&#xD;
my $lock = File::NFSLock-&gt;new($0, LOCK_EX|LOCK_NB);&#xD;
die "$0 is already running!n" unless $lock;&#xD;
&#xD;
my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) = localtime(time);&#xD;
$year += 1900;&#xD;
$mon += 1;&#xD;
my $datestring = time2str( "%m-%d-%Y", time );&#xD;
$logfile="/var/log/s3backup-$datestring.log";&#xD;
&#xD;
open( LOGFILE , "&gt;&gt; $logfile" )&#xD;
 or die "Can't open file '$logfile'. $!n";&#xD;
select((select(LOGFILE), $| = 1)[0]); # autoflush LOGFILE&#xD;
&#xD;
sub logh() {&#xD;
 my $msg = shift(@_);&#xD;
 my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);&#xD;
 $mon += 1; $wday += 1; $year += 1900;&#xD;
&#xD;
my @months = qw { Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec };&#xD;
 my $dts;&#xD;
 $dts = sprintf("%04d%3s%02d %02d:%02d:%02d",&#xD;
 $year,$months[$mon],$mday,$hour,$min,$sec);&#xD;
 my $pid = $$;&#xD;
 printf LOGFILE ("$dts:$pid: $msgn" , @_);&#xD;
}&#xD;
&#xD;
sub backupDir {&#xD;
 &amp;logh("Creating tarball of directories");&#xD;
 $dirfilename="data-$datestring.tar.gz";&#xD;
 if (-e "/backups/$dirfilename") {&#xD;
 &amp;logh("Error: Backup file already exists: /backups/$dirfilename");&#xD;
 }&#xD;
 else {&#xD;
 my $dirbak=`tar czPvf "/backups/Data/$dirfilename" $datadirs`;&#xD;
 &amp;logh("Directories tarball has been created");&#xD;
 }&#xD;
&#xD;
}&#xD;
&#xD;
sub mysqlBackup {&#xD;
 my $user ="root";&#xD;
 my $password = "### INPUT ROOT MYSQL PASSWORD ###";&#xD;
 my $outputdir = "/backups/MySQL";&#xD;
 my $mysqldump = "/usr/bin/mysqldump";&#xD;
 my $mysql = "/usr/bin/mysql";&#xD;
&#xD;
&amp;logh("Creating MySQL backup dump");&#xD;
 $msqlfilename="mysql-$datestring.tar.gz";&#xD;
 if (-e "/backups/$msqlfilename") {&#xD;
 &amp;logh("Error: MySQL backup file already exists: /backups/$dirfilename");&#xD;
 }&#xD;
 else {&#xD;
 system("rm -rf $outputdir/*.gz");&#xD;
 &amp;logh("Deleted old backups..");&#xD;
 my @dblist = `$mysql -u$user -p$password -e 'SHOW DATABASES;' | grep -Ev '(Database|information_schema)'`;&#xD;
 for $db (@dblist) {&#xD;
 chomp($db);&#xD;
 my $execute = `$mysqldump -u $user -p$password $db | gzip &gt; $outputdir/$db.sql.gz`;&#xD;
 }&#xD;
 my $mysqlbak=`tar czvf "/backups/Data/$msqlfilename" $outputdir/*.gz`;&#xD;
 system("rm -rf $outputdir/*.gz");&#xD;
 &amp;logh("MySQL Backup dump has been created.");&#xD;
&#xD;
}&#xD;
}&#xD;
&#xD;
sub createOne {&#xD;
 &amp;logh("Merging backups into one file");&#xD;
 my $filename="ServerBackup-$datestring.tar.gz";&#xD;
 if (-e "/backups/$filename") {&#xD;
 &amp;logh("Error: Backup file already exists: /backups/$filename");&#xD;
 }&#xD;
 else {&#xD;
 my $arbak=`tar czvf /backups/Archive/$filename /backups/Data/*.gz`;&#xD;
 system("rm -rf /backups/MySQL/* /backups/Data/*");&#xD;
 &amp;logh("Merge complete.");&#xD;
 }&#xD;
}&#xD;
&#xD;
sub syncS3 {&#xD;
 &amp;logh("Syncing to S3.. ");&#xD;
 my $sync=`s3cmd sync --delete-removed /backups/Archive/ s3://### INPUT YOUR BUCKET NAME ### &gt;&gt; $logfile`;&#xD;
 if ($? == 0) { &amp;logh("Sync to s3 complete."); }&#xD;
}&#xD;
&#xD;
sub cleanArchive {&#xD;
 &amp;logh("Removing backups older than 7 days");&#xD;
 system("find /backups/Archive -type f -mtime +7 -print | xargs rm");&#xD;
 &amp;logh("Delete complete.");&#xD;
}&#xD;
&#xD;
&amp;cleanArchive;&#xD;
&#xD;
my $filename="ServerBackup-$datestring.tar.gz";&#xD;
if (-e "/backups/Archive/$filename") {&#xD;
 &amp;logh("Error: Backup file already exists: /backups/$filename");&#xD;
 exit 1;&#xD;
}&#xD;
&#xD;
&amp;backupDir;&#xD;
&amp;mysqlBackup;&#xD;
&amp;createOne;&#xD;
&amp;syncS3;&#xD;
```&#xD;
&#xD;
In the above script you only need to change 3 values if you wish for your server to keep 7 days of backups, just search and replace the following values:&#xD;
&#xD;
```&#xD;
### INPUT YOUR DIRECTORIES ###&#xD;
### INPUT YOUR BUCKET NAME ###&#xD;
### INPUT ROOT MYSQL PASSWORD ###&#xD;
```&#xD;
&#xD;
You may also want to look at the sub mysqlBackup function if your MySQL installation is special or if you don't want to use the root user to login and backup your databases. Once you have done all that, simply test out the script by running it and if all is well then create a cron job to automatically run it every so often. I've also been meaning to make a mail function in this script to email me when a backup is completed/created I just haven't had the time to get around to it.. I'll update this post when I do so.&#xD;
</content>
  </entry>
  <entry>
    <title>Bash script to create MySQL database and user</title>
    <author/>
    <content>I don't know about you, but often times I find myself needing to create a MySQL database and I simply forget all of the commands. This is really something that I should remember, but for some strange reason I just never am able to remember it. So like any other admin would do, you script it out to make it easier on yourself. This bash script will allow you to create new databases on the fly quickly and easily. This has been nothing but a time-saver.&#xD;
&#xD;
```bash&#xD;
#!/bin/bash&#xD;
&#xD;
echo -n "Enter the MySQL root password: "&#xD;
read -s rootpw&#xD;
echo -n "Enter database name: "&#xD;
read dbname&#xD;
echo -n "Enter database username: "&#xD;
read dbuser&#xD;
echo -n "Enter database user password: "&#xD;
read dbpw&#xD;
&#xD;
db="create database $dbname;GRANT ALL PRIVILEGES ON $dbname.* TO $dbuser@localhost IDENTIFIED BY '$dbpw';FLUSH PRIVILEGES;"&#xD;
mysql -u root -p$rootpw -e "$db"&#xD;
&#xD;
if [ $? != "0" ]; then&#xD;
 echo "[Error]: Database creation failed"&#xD;
 exit 1&#xD;
else&#xD;
 echo "------------------------------------------"&#xD;
 echo " Database has been created successfully "&#xD;
 echo "------------------------------------------"&#xD;
 echo " DB Info: "&#xD;
 echo ""&#xD;
 echo " DB Name: $dbname"&#xD;
 echo " DB User: $dbuser"&#xD;
 echo " DB Pass: $dbpw"&#xD;
 echo ""&#xD;
 echo "------------------------------------------"&#xD;
fi&#xD;
```&#xD;
</content>
  </entry>
  <entry>
    <title>Bash Tips And Tricks (Part 1)</title>
    <author/>
    <content>I have always thought of bash as a "Quick 'n Dirty" way of taking care of things, it isn't by any means a powerful language. It's not meant for writing programs, not meant for creating games, not meant for much other than linux system administration. My "Rule Of Thumb", is if someone gives me a task to complete, I do it manually, if they come twice or three times, I automate it. If I think it will take more than 100 lines of code, I use something other than bash.... Perl or Python perhaps. I don't usually use PHP for CLI apps, but sometimes there are exceptions to the rule. Below are a few tricks I have learned while creating some bash scripts.Feel free to add your own in the comments!&#xD;
&#xD;
#### 1) Getting The Correct Error Code Of A Command Thats Before A Pipe&#xD;
&#xD;
A lot of bash scripting consists of executing one thing, and having the output piped ( **|** ) into another command, for example...&#xD;
&#xD;
```bash&#xD;
$ /usr/bin/w | grep jhyland | wc -l&#xD;
1&#xD;
```&#xD;
&#xD;
This executes the _/usr/bin/w_ binary, then pipes it to the _grep_ command, which will only return lines that has jhyland in it, then counts the number of lines. So now we know that jhyland is logged into this server only once. Another commonly used tactic is getting the exit code of the last command, which is the $? variable. You can execute a command, then with a conditional statement, see what the exit code was, and process something else accordingly, example below.&#xD;
&#xD;
```bash&#xD;
#!/bin/bash&#xD;
&#xD;
mkdir /tmp/jhyland&#xD;
&#xD;
if [[ $? -ne 0 ]]&#xD;
then&#xD;
 echo "Error while creating /tmp/jhyland"&#xD;
 exit 1&#xD;
else&#xD;
 echo "/tmp/jhyland has been created"&#xD;
fi&#xD;
```&#xD;
&#xD;
The $? will either return 0 (success) or 1 (fail). But what about that command I showed you above? The /usr/bin/w | grep jhyland | wc -l, if that gets executed, then $? will show the exit code for the wc -l part, when what you really want, is the exit code for the /usr/bin/w command. The solution is the system variable $PIPESTATUS, (Well, I guess it's an array). This holds all of the exit codes for every command that was previously ran (Keep in mind, this gets reset every time you run a new command. Heres an example:&#xD;
&#xD;
```bash&#xD;
#!/bin/bash&#xD;
&#xD;
/usr/bin/w | grep jhyland | wc -l&#xD;
&#xD;
if [[ ${PIPESTATUS[0]} -ne 0 ]]&#xD;
then&#xD;
echo "Error while running /usr/bin/w"&#xD;
exit 1&#xD;
else&#xD;
echo "/usr/bin/w ran just fine"&#xD;
fi&#xD;
```&#xD;
&#xD;
Here's a slightly better example of how to leverage it:&#xD;
&#xD;
```bash&#xD;
#!/bin/bash&#xD;
&#xD;
user="jhyland"&#xD;
ip="192.168.1"&#xD;
&#xD;
who | grep $user | grep $ip &amp;&gt;/dev/null&#xD;
&#xD;
if [[ ${PIPESTATUS[1]} -ne 0 ]]; then&#xD;
 echo "No $user on this server"&#xD;
elif [[ ${pipestatus[2]} -ne 0 ]]; then&#xD;
 echo "The user $user is on this server, just not from an IP matching $ip"&#xD;
else&#xD;
 echo "The user $user is on this server, from an IP matching $ip"&#xD;
fi&#xD;
```&#xD;
&#xD;
[Heres a more in-depth tutorial.](/articles/viewing-bash-exit-status-codes-with-pipes.html)&#xD;
&#xD;
___&#xD;
#### 2) Using _&amp;&amp;_ and _||_ Instead of Conditional Statements&#xD;
Most Bash scripting is comprised of executing commands, then executing more commands based off of the output or result of the previous command.&#xD;
&#xD;
If you learn how to use the _&amp;&amp;_ and _||_ operators, you'll find you can convert a lot of scripts to one-liners, or reduce the amount of lines in some of your existing scripts.&#xD;
&#xD;
The _||_ operator is basically "OR", it's somewhat like using the _-ne_ operator in a conditional statement.&#xD;
&#xD;
Small example... This following script just creates a directory, then backsup (tar's) a directory and throws the tar into the newly created directory&#xD;
&#xD;
```bash&#xD;
mkdir -p  /some/test/directory &amp;&gt;/dev/null&#xD;
if [[ $? -ne 0 ]]; then&#xD;
    exit 1&#xD;
fi&#xD;
&#xD;
tar cvfz /some/test/directory/backup_file.tar.gz /tmp &amp;&gt;/dev/null&#xD;
if [[ $? -ne 0 ]]; then&#xD;
    exit 1&#xD;
fi&#xD;
```&#xD;
&#xD;
Now this little script can actually be reduced down to two lines of code, using the _||_ operator. Heres the example..&#xD;
&#xD;
```bash&#xD;
mkdir -p /some/test/directory &amp;&gt;/dev/null || exit 1&#xD;
tar cvfz /some/test/directory/backup_file.tar.gz /tmp &amp;&gt;/dev/null ||  exit 1&#xD;
```&#xD;
&#xD;
Those two snippets do the exact same thing!&#xD;
&#xD;
Let's get a little more complicated. Lets add confirmations into the script.&#xD;
&#xD;
```bash&#xD;
mkdir -p  /some/test/directory &amp;&gt;/dev/null&#xD;
if [[ $? -ne 0 ]]; then&#xD;
    echo "Failed to mkdir"&#xD;
    exit 1&#xD;
else&#xD;
    echo "Successfully mkdir'd"&#xD;
fi&#xD;
&#xD;
tar cvfz /some/test/directory/backup_file.tar.gz /tmp &amp;&gt;/dev/null&#xD;
if [[ $? -ne 0 ]]; then&#xD;
    echo "Failed to tar"&#xD;
    exit 1&#xD;
else&#xD;
    echo "Successfully tar'd"&#xD;
fi&#xD;
```&#xD;
&#xD;
That does the same thing as the previous snippets, only it's a little more verbose. You wouldn't immediately think that you can convert that into a two liner, but you actually can...&#xD;
&#xD;
```bash&#xD;
(mkdir -p /some/test/directory &amp;&gt;/dev/null &amp;&amp; echo "Successfully mkdir'd") || (echo "Failed to mkdir" &amp;&amp; exit 1)&#xD;
(tar cvfz /some/test/directory/backup_file.tar.gz /tmp &amp;&gt;/dev/null &amp;&amp; echo "Successfully tar'd") || (echo "Failed to tar" &amp;&amp; exit 1)&#xD;
```&#xD;
&#xD;
You can group commands using parentheses, then use the _&amp;&amp;_ and _||_ operators.&#xD;
&#xD;
One more small example... this is a one liner that ensures the username AND password os set previously in the script, if not, displays whatsup and exits with the proper exit code&#xD;
&#xD;
```bash&#xD;
[[ -z $username || -z $password ]] &amp;&amp; (echo "Username or password null" &amp;&amp; exit 1)&#xD;
```&#xD;
&#xD;
It's a little more difficult to read, but very useful!&#xD;
___&#xD;
#### 3) Brace Expressions&#xD;
Utilizing the Brace Expression around a list of worts, allows you to print a list of words with the same prefix and suffix to the words. Here is an example via the CLI of me using the Brace Expression with a suffix:&#xD;
&#xD;
```bash&#xD;
echo {inspi,admi,ado,abju,ac,adhe,inji}red inspired admired adored abjured acred adhered injired&#xD;
```&#xD;
&#xD;
Example with a prefix:&#xD;
&#xD;
```bash&#xD;
echo red{act,an,argue,der,dens,bay} redact redan redargue redder reddens redbay&#xD;
```&#xD;
&#xD;
Now this is a pretty useful trick, but for a while, I just wasn't sure what to use it for, but I guess you can do something like this...&#xD;
&#xD;
```bash&#xD;
#!/bin/bash&#xD;
&#xD;
# Get all of the hostnames out of the apache settings output, replace the returns with ,&#xD;
hosts=$(/usr/sbin/httpd -S 2&gt;&amp;1 | grep namevhost | awk '{print $4}' | tr '\n' ',')&#xD;
&#xD;
# Compress all apache logs&#xD;
tar cvfz apache_logs.tar.gz $(eval echo /var/log/httpd/{$hosts}.log)&#xD;
```&#xD;
&#xD;
That would tar and compress any  of the log files for any active sites into apache_logs.tar.gz &lt;strong&gt; NOTE:&lt;/strong&gt; If you are using a variable within the curly braces, like above (The $hosts variable within {}), then you need to use the eval statement.&#xD;
___&#xD;
#### 4) Backticks vs $()&#xD;
I was originally taught to use backticks for command substitution, heres a small example:&#xD;
&#xD;
```bash&#xD;
[jhyland@svr2 ~]$ echo "My name is `whoami` and I am in `pwd`";&#xD;
 My name is jhyland and I am in /home/jhyland&#xD;
```&#xD;
&#xD;
But if you do enough Bash scripting, you will see an issue... How do you nest commands? Meaning, if you need to execute backticks within backticks, it gets pretty messy. You have to escape every nested backtick, and that would be a pretty ugly script! But if you choose to use **$()** instead of backticks, then it gets much simpler.&#xD;
&#xD;
```bash&#xD;
echo "The file you are looking for is $(find /home/$(whoami)/Downloads/ -name \'bla-install*.tar.gz)\'"&#xD;
```&#xD;
&#xD;
See how you can execute the find command in a subshell, as well as the whoami statement, which is inside of a subshell, inside of another subshell? Thats why you should use $() and not \`\`&#xD;
___&#xD;
&#xD;
#### 5) Using Arrays Instead Of Multiple Variables&#xD;
You don't have to be a very experienced developer to know that using an array is better than using a ton of variables. Arrays are better for multiple reasons... You can manipulate them in nearly any way. So instead of doing this...&#xD;
&#xD;
```bash&#xD;
#!/bin/bash&#xD;
color1='Blue'&#xD;
color2='Red'&#xD;
color3='Yellow'&#xD;
color4='Black'&#xD;
echo "Colors: $color1, $color2, $color3, $color4."&#xD;
# Output: Colors: Blue, Red, Yellow, Black.&#xD;
```&#xD;
&#xD;
Why not do it the smart way? You can use an array to store the colors. Try this:&#xD;
&#xD;
```bash&#xD;
#!/bin/bash&#xD;
colors=('Blue' 'Red','Yellow','Black')&#xD;
echo "Colors: ${colors[0]}, ${colors[1]}, ${colors[2]}, ${colors[3]}"&#xD;
# Output: Colors: Blue, Red, Yellow, Black.&#xD;
```&#xD;
&#xD;
Same output, but less lines of code, and you can add values to it, delete values, reorder it, etc etc. NOTE: The only thing that sucks about arrays in Bash... is the keys have to be numeric. Meaning you cant have ${name[a]} or anything of that sort. The keys are always numeric, never alphabetic.&#xD;
___&#xD;
#### 6) The 'test' Utility&#xD;
Not many people are aware of the test command. Basically, it lets you test a condition, without being in a conditional statement. You just use it to test a condition and it will return an exit code (1 or 0). Here is an example of how you could use it.&#xD;
&#xD;
```bash&#xD;
#!/bin/bash&#xD;
&#xD;
dir=$(test -d $1)&#xD;
&#xD;
if [[ $dir -eq "0" ]]&#xD;
then&#xD;
 the dir exists&#xD;
fi&#xD;
```&#xD;
&#xD;
Now I realize you could just put the condition inside of the if statement itself, but the point is that now you can use $dir all over your script, or use it to compare to other test results.&#xD;
___&#xD;
&#xD;
#### 7) Default Bash Variable Values&#xD;
There are many instances where you want to set a default value for a variable. A lot of people will do something like this:&#xD;
&#xD;
```bash&#xD;
#!/bin/bash&#xD;
&#xD;
first=$1&#xD;
last=$2&#xD;
&#xD;
if [[ ! $first ]]&#xD;
then&#xD;
 first="John"&#xD;
fi&#xD;
&#xD;
if [[ ! $last ]]&#xD;
then&#xD;
 last="Doe"&#xD;
fi&#xD;
&#xD;
echo "Your name is $first $last"&#xD;
```&#xD;
But theres a much easier way:&#xD;
&#xD;
```bash&#xD;
#!/bin/bash&#xD;
&#xD;
# Preferred way of setting a default value to a variable&#xD;
# (If $1 isn't null, set value of $first to $1, otherwise,&#xD;
# set value of $first to "John")&#xD;
first=${1:-John}&#xD;
&#xD;
# Old school method, whats used in some older bash scripts&#xD;
# (if $2 is non-zero, then set $last to value of $2, if&#xD;
# $2 is empty, then set $last to "doe")&#xD;
[ -n "$2" ] &amp;&amp; last=$2 || last="doe"&#xD;
&#xD;
echo "Your name is $first $last"&#xD;
```&#xD;
&#xD;
Using the **${variable:-default value}** method saves you time and space, and is a much easier to utilize variables with default values.&#xD;
___&#xD;
&#xD;
#### 8) Align Your Content, Make It Pretty&#xD;
Typically, when you need to align your output to make it pretty, you would use tabs, or printf, but I found a better way to do so, and i've used it ever since. The command is called **column**, specifically "**column -t**". Heres an example of a simple command of me looking at the passwd file. Lets take a look at the output:&#xD;
&#xD;
```bash&#xD;
# egrep "^(geoff|justin|kyle)" /etc/passwd | awk -F: '{print "User", $1, "Home:", $6}' User geoff Home: /home/geoff User justin Home: /home/justin User kyle Home: /home/kyle&#xD;
```&#xD;
&#xD;
Pretty basic, just a little ugly huh? Lets try adding **column -t** to the end of it...&#xD;
&#xD;
```bash&#xD;
# egrep "^(geoff|justin|kyle)" /etc/passwd | awk -F: '{print "User", $1, "Home:", $6}' | column -t User geoff Home: /home/geoff User justin Home: /home/justin User kyle Home: /home/kyle&#xD;
```&#xD;
&#xD;
You can see that theres a difference in the way the columns are laid out. The **column -t** aligns the columns perfectly. This is useful for the **/bin/mount** and **/bin/df** commands as well, we all know how ugly those are, but if you add _column -t_, it turns it into something somewhat representable:&#xD;
&#xD;
```bash&#xD;
$ mount | column -t&#xD;
/dev/simfs  on  /                         type  simfs&#xD;
(rw,relatime,usrquota,grpquota)&#xD;
proc        on  /proc                     type  proc         (rw,relatime)&#xD;
sysfs       on  /sys                      type  sysfs        (rw,relatime)&#xD;
none        on  /dev                      type  tmpfs        (rw,relatime)&#xD;
none        on  /dev/pts                  type  devpts       (rw,relatime)&#xD;
none        on  /proc/sys/fs/binfmt_misc  type  binfmt_misc  (rw,relatime)&#xD;
$ df | column -t&#xD;
Filesystem  1K-blocks  Used     Available  Use%  Mounted  on&#xD;
/dev/simfs  52428800   6981724  45447076   14%   /&#xD;
none        1048576    4        1048572    1%    /dev&#xD;
```&#xD;
&#xD;
___&#xD;
&#xD;
#### 9) Use double brackets for conditionals, more "superior"&#xD;
You can code an if statement in bash with either single brackets..&#xD;
&#xD;
```bash&#xD;
if [ $this == \'that\' ];&#xD;
```&#xD;
&#xD;
or you can use the double brackets&#xD;
&#xD;
```bash&#xD;
if [[ $this == 'that' ]];&#xD;
```&#xD;
&#xD;
Both of these will operate the same way if $this is set to 'that', but if its not set, or its null, then the first one will fail, first one will throw a syntax error in the if statement.&#xD;
&#xD;
The double brackets also allow regex matching as well, which can only be accomplished in if statements with single brackets if you execute a subshell and using some form of grep.&#xD;
&#xD;
Double brackets are also backwards compatible. So theres nothing extra that needs to be done other than a simple find/replace to replace the single brackets to double.&#xD;
&#xD;
#### 10) Hide Your Grep Result More Efficiently With Grep&#xD;
You know how when you grep for something, the actual grep line shows up? Example...&#xD;
&#xD;
```bash&#xD;
# ps aux |grep something&#xD;
root      4155  0.0  0.0  13632   952 pts/2    S+   23:16   0:00 grep --colour=auto something&#xD;
jdoe  29731  1.0  0.0  20256  1176 pts/0    S+   20:30   1:47 tar cvfz something.tar.gz directory&#xD;
```&#xD;
&#xD;
Typically people just add _| grep -v grep_, but what if that hides something that you want to see?&#xD;
&#xD;
Well heres a little tip, if you surround the first character in brackets, then it will exclude the grep command itself.. Example:&#xD;
&#xD;
```bash&#xD;
# ps aux |grep [s]omething&#xD;
jdoe  29731  1.0  0.0  20256  1176 pts/0    S+   20:30   1:47 tar cvfz something.tar.gz directory&#xD;
```&#xD;
</content>
  </entry>
  <entry>
    <title>Bash Trick - Display Timestamp For Each Command In History</title>
    <author/>
    <content>Ever go through your _history_, and wish you knew the exact date and time a given command was typed? Well theres actually a fairly simple trick. It's the global _HISTTIMEFORMAT_ variable.&#xD;
&#xD;
To test it out, copy and paste the following into your bash prompt, type a few commands, then type _history_ again.&#xD;
```bash&#xD;
$ HISTTIMEFORMAT="%d/%m/%y %T "&#xD;
```&#xD;
&#xD;
You should see the typical history output, with the date and time prepended to each line. Heres an example from my _history_ output.&#xD;
```bash&#xD;
  497  24/04/14 01:16:46 man nmap&#xD;
  498  24/04/14 01:16:46 sudo su -&#xD;
  499  24/04/14 01:16:46 sudo su -&#xD;
  500  24/04/14 01:16:46 exit&#xD;
  501  24/04/14 01:16:53 clear&#xD;
  502  24/04/14 01:16:54 HISTTIMEFORMAT="%d/%m/%y %T "&#xD;
  503  24/04/14 01:16:57 ls&#xD;
  504  24/04/14 01:17:04 whoami&#xD;
  505  24/04/14 01:17:17 ps aux |grep bla&#xD;
  506  24/04/14 01:17:20 history |tail&#xD;
```&#xD;
&#xD;
Now if you want this to be permanent, then execute the following, to add it to your _.bash_profile_&#xD;
```bash&#xD;
$ echo 'export HISTTIMEFORMAT="%d/%m/%y %T "' &gt;&gt; ~/.bash_profile&#xD;
```&#xD;
</content>
  </entry>
</feed>